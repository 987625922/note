# JVM

1. jvm结构

   - 堆
   - 栈
   - 本地方法栈
   - 程序计数器
   - 方法区

2. 程序计数器

   每个线程都有各自的计数器，记录线程运行class文件的行号，唯一没有规定OOM的区域

3. 栈

   每个线程都有各自的JAVA虚拟机栈，先入栈的方法后出栈，作用于方法执行的一块JAVA内存区域。每个方法在执行的同时会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息，每一个方法从调用到执行完成的过程对应着一个栈帧在栈中入栈到出栈的过程。局部变量表存储的是已知大学的基本数据类型和对象的引用（比如，int对应4个字节，对象的指针等等）如果线程请求的深度大于虚拟机允许的深度将抛出StackOverflowError（递归一个方法可以测试这个问题）

4. 本地方法栈

   每个线程都有各自的本地方法栈，执行Native方法，其他的JAVA虚拟机栈一样，Hotspot将JAVA虚拟机栈和本地方法栈合为一个

5. 堆

   线程共享，几乎所有的对象实例和数组都在这里分配内存。

6. 方法区

   线程之间共享，作用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据

   - 运行时常量池

     属于方法区一部分，class文件除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分将在类加载后进入方法区的运行时常量池中存放

7. 对象是怎么来的？

   - 对象创建的顺序：
     1. 检查是否已被加载
     2. 执行类加载，解析，初始化
     3. 为新生对象分配内存空间
     4. 将分配的内存空间初始化为零值
     5. 设置对象头的相关数据（GC分代年龄，对象的哈希码，元数据信息）
     6. 执行对象的<init>方法
   - 对象分配内存的方式：
     - 指针碰撞
     - 空闲列表

   - 对象的内存分布

     分3部分：对象头Header，实例数据，对齐填充

     1. 对象头用于存储对象的元数据信息：Markword部分数据的长度在32位何64位虚拟机（为开启指针压缩）中分别为32bit和64bit，存储对象自身的运行时数据如哈希值，类型指针。
     2. 实例数据存储真正有效的数据，如各种字段内容
     3. 对齐填充仅仅起到占位符的作用

   - 怎么访问你的对象

     当我们在堆上创建一个对象实例后，就要通过虚拟机栈中的reference类型数据来操作堆上的对象，现在主流的有2种：

     - 使用句柄访问对象
     - 直接指针访问对象
   
8. 垃圾收集算法

   1. 引用计数法（判断对象是否被使用）
   2. 可达性分析（判断对象是否被使用）
   3. 标记-清除算法（收集算法）
   4. 复制算法（收集算法）
   5. 标记整理（老年代收集算法）
   6. 分代收集算法（分新生代和老年代）

9. 垃圾收集器

   收集算法是内存收集的方法论，垃圾收集器是内存回收的具体实现

   - serial垃圾收集器

     一个单线程的垃圾收集器，使用复制算法，用户线程需要等待GC完成

   - ParNew收集器

     serial的多线程版本，是新生代收集器，使用-XX ParallelGCThreads参数来限制垃圾收集的线程数，最好对应CPU核数

   - Parallel Scavenge收集器

     一个新生代收集器，使用复制算法的睡觉去，又是并行的多线程收集器。由于与吞吐量关系密切，也常称为吞吐量优先收集器，目标是达到可控的吞吐。

     吞吐量=运行用户代码时间 / （运行用户代码时间 + 垃圾收集收集）

     -XX:MaxGCPauseMillis GC停顿收集，太小会导致频繁GC

     -XX:GCTimeRatio

   - Serial old收集器

     一个单线程收集器，使用标记-整理算法

   - Parralledl old收集器

     老年代版本，使用多线程+标记整理算法

   - CMS垃圾收集器

     并发收集器，一种以获取最短回收停顿时间为目标的事情，基于标记清除算法实现

   - G1垃圾收集器

     面向服务端，基于标记整理

10. JVM内存分配

    - 堆分布：新生代，老年代

    - 堆内存分配

      对象主要分配在新生代的Eden区上，少数情况下也可能会直接分配在老年代中。

      新生代GC（MinotGC）:因为大多数对象都具备朝生夕灭的特性，MinotGC非常频繁。

      老年代GC（MajiorGC/FullGC）：老年代区的GC

      GC测试：-Xms20.-Xmx20m，-Xmn10m，VM opetion

11. 大对象分配

    -XX：PretenuresizeThreshold参数，设置直接在老年代分配内存的大小，可以避免在Eden去及两个survivor区之间发生大的内存复制

    实战代码演练大对象配置：-verboseigc-xx：+PrintGCDetails开启GC日志打印；-Xms20m：设置JVM初始内存为20m；-Xmx20M：设置JVM最大内存为20M；-Xmn10M：设置新生代内存为10M

12. 逃逸分析

    开启后就会使用栈上分配，JDK1.8默认开启，方法逃逸和线程逃逸

13. 虚拟机工具

    - JPS

      JPS给你和PS(ps -ef|grep java)类似

      jps -l 输出主类的全名

      jps -v 输出虚拟机进程启动时JVM参数 

    - jstat

      显示虚拟机进程中的类装在，内存，垃圾收集，JT编译等运行数据。

      jstat -gc 2764 250 20  //2764表示进程id，250毫秒打印异常，打印20次

    - jinfo

      查看和调整虚拟机各项参数 

      jinfo -flag 1444 //1444是PID

    - jmap

      用于生成堆转储快照，还有一个手段：-xx：+HeapDumpOnOutofMemoryError参数

      jmap -dump：format=b,file=/Users/daniell/deskTop //生成Java堆转储快照

      jmap -histo PID //显示堆中对象统计信息

    - jhat（使用不多）

      分析jmap生成的堆转储快照

    - jstack

      用于生成虚拟机当前时刻的线程快照，线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程在后台做些什么，或者在等待什么

      jstack -i 3500

14. 线程死锁

    由于两个或多个线程互相持有对方所需的资源，导致线程处于等待状态。jstack可以用来定位死锁

    线程状态：NEW,PUNNABLE,BLOCKED,WAITING,TERMINATED,TIMED_WAITING

15. JVM常见问题

    - 单个接口请求慢：使用explain来查看是不是mysql语句有问题
    - 整体接口慢：查看JVM是否频繁FullGC

